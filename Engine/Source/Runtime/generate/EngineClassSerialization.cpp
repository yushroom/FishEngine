
/**************************************************
* auto generated by reflection system
**************************************************/

#include <Archive.hpp>
#include <private/CloneUtility.hpp>
#include "../AnimationClip.hpp" 
#include "../IntVector.hpp" 
#include "../Texture.hpp" 
#include "../ShaderProperty.hpp" 
#include "../CameraController.hpp" 
#include "../Script.hpp" 
#include "../Renderer.hpp" 
#include "../SkinnedMeshRenderer.hpp" 
#include "../Bounds.hpp" 
#include "../Scene.hpp" 
#include "../Frustum.hpp" 
#include "../MeshRenderer.hpp" 
#include "../Prefab.hpp" 
#include "../MeshFilter.hpp" 
#include "../Color.hpp" 
#include "../CapsuleCollider.hpp" 
#include "../Animation/AnimationState.hpp"
#include "../Rect.hpp" 
#include "../Ray.hpp" 
#include "../Shader.hpp" 
#include "../Transform.hpp" 
#include "../Texture2D.hpp" 
#include "../Material.hpp" 
#include "../Component.hpp" 
#include "../Animation/AnimationEvent.hpp"
#include "../Animation/AnimationClipInfo.hpp"
#include "../Behaviour.hpp" 
#include "../Mesh.hpp" 
#include "../Collider.hpp" 
#include "../Object.hpp" 
#include "../Cubemap.hpp" 
#include "../BoneWeight.hpp" 
#include "../BoxCollider.hpp" 
#include "../Light.hpp" 
#include "../Camera.hpp" 
#include "../Skybox.hpp" 
#include "../SphereCollider.hpp" 
#include "../Shader/ShaderLabProperties.hpp" 
#include "../GameObject.hpp" 
#include "../Avatar.hpp" 
#include "../Animator.hpp" 
#include "../Rigidbody.hpp" 
#include "../Animation.hpp" 

namespace FishEngine
{

	// FishEngine::AnimatorClipInfo
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimatorClipInfo const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("clip", value.clip); // std::shared_ptr<AnimationClip>
		archive << FishEngine::make_nvp("weight", value.weight); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimatorClipInfo & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("clip", value.clip); // std::shared_ptr<AnimationClip>
		archive >> FishEngine::make_nvp("weight", value.weight); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Ray
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Ray const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("origin", value.origin); // FishEngine::Vector3
		archive << FishEngine::make_nvp("direction", value.direction); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Ray & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("origin", value.origin); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("direction", value.direction); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	// FishEngine::Skybox
	void FishEngine::Skybox::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_material", m_material); // MaterialPtr
		//archive.EndClass();
	}

	void FishEngine::Skybox::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_material", m_material); // MaterialPtr
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Skybox::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Skybox>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Skybox::CopyValueTo(std::shared_ptr<FishEngine::Skybox> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Behaviour::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_material, target->m_material); // MaterialPtr
	}


	// FishEngine::Object
	void FishEngine::Object::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		archive << FishEngine::make_nvp("m_objectHideFlags", m_objectHideFlags); // FishEngine::HideFlags
		archive << FishEngine::make_nvp("m_name", m_name); // std::string
		archive << FishEngine::make_nvp("m_prefabParentObject", m_prefabParentObject); // PrefabPtr
		archive << FishEngine::make_nvp("m_prefabInternal", m_prefabInternal); // PrefabPtr
		//archive.EndClass();
	}

	void FishEngine::Object::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		archive >> FishEngine::make_nvp("m_objectHideFlags", m_objectHideFlags); // FishEngine::HideFlags
		archive >> FishEngine::make_nvp("m_name", m_name); // std::string
		archive >> FishEngine::make_nvp("m_prefabParentObject", m_prefabParentObject); // PrefabPtr
		archive >> FishEngine::make_nvp("m_prefabInternal", m_prefabInternal); // PrefabPtr
		//archive.EndClass();
	}



	// FishEngine::Collider
	void FishEngine::Collider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_contactOffset", m_contactOffset); // float
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive << FishEngine::make_nvp("m_isTrigger", m_isTrigger); // bool
		//archive.EndClass();
	}

	void FishEngine::Collider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_contactOffset", m_contactOffset); // float
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive >> FishEngine::make_nvp("m_isTrigger", m_isTrigger); // bool
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Collider::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		abort();
		return nullptr;
	}

	void FishEngine::Collider::CopyValueTo(std::shared_ptr<FishEngine::Collider> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_contactOffset, target->m_contactOffset); // float
		cloneUtility.Clone(this->m_enabled, target->m_enabled); // bool
		cloneUtility.Clone(this->m_isTrigger, target->m_isTrigger); // bool
	}


	// FishEngine::Animator
	void FishEngine::Animator::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::Animator::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Animator::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Animator>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Animator::CopyValueTo(std::shared_ptr<FishEngine::Animator> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
	}


	// FishEngine::CameraController
	void FishEngine::CameraController::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Script::Serialize(archive);
		archive << FishEngine::make_nvp("m_lookAtMode", m_lookAtMode); // bool
		archive << FishEngine::make_nvp("m_rotateSpeed", m_rotateSpeed); // float
		archive << FishEngine::make_nvp("m_dragSpeed", m_dragSpeed); // float
		archive << FishEngine::make_nvp("m_orbitCenter", m_orbitCenter); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::CameraController::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Script::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_lookAtMode", m_lookAtMode); // bool
		archive >> FishEngine::make_nvp("m_rotateSpeed", m_rotateSpeed); // float
		archive >> FishEngine::make_nvp("m_dragSpeed", m_dragSpeed); // float
		archive >> FishEngine::make_nvp("m_orbitCenter", m_orbitCenter); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::CameraController::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::CameraController>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::CameraController::CopyValueTo(std::shared_ptr<FishEngine::CameraController> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Script::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_lookAtMode, target->m_lookAtMode); // bool
		cloneUtility.Clone(this->m_rotateSpeed, target->m_rotateSpeed); // float
		cloneUtility.Clone(this->m_dragSpeed, target->m_dragSpeed); // float
		cloneUtility.Clone(this->m_orbitCenter, target->m_orbitCenter); // FishEngine::Vector3
	}


	// FishEngine::Material
	void FishEngine::Material::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_textures", m_textures); // std::map<std::string, TexturePtr>
		archive << FishEngine::make_nvp("m_uniforms", m_uniforms); // FishEngine::ShaderUniforms
		archive << FishEngine::make_nvp("m_properties", m_properties); // std::vector<MaterialProperty>
		//archive.EndClass();
	}

	void FishEngine::Material::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_textures", m_textures); // std::map<std::string, TexturePtr>
		archive >> FishEngine::make_nvp("m_uniforms", m_uniforms); // FishEngine::ShaderUniforms
		archive >> FishEngine::make_nvp("m_properties", m_properties); // std::vector<MaterialProperty>
		//archive.EndClass();
	}



	// FishEngine::Texture2D
	void FishEngine::Texture2D::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Texture::Serialize(archive);
		archive << FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive << FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	void FishEngine::Texture2D::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Texture::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive >> FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}



	// FishEngine::MeshFilter
	void FishEngine::MeshFilter::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_mesh", m_mesh); // MeshPtr
		//archive.EndClass();
	}

	void FishEngine::MeshFilter::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_mesh", m_mesh); // MeshPtr
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::MeshFilter::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::MeshFilter>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::MeshFilter::CopyValueTo(std::shared_ptr<FishEngine::MeshFilter> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_mesh, target->m_mesh); // MeshPtr
	}


	// FishEngine::BoxCollider
	void FishEngine::BoxCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_size", m_size); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::BoxCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_size", m_size); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::BoxCollider::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::BoxCollider>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::BoxCollider::CopyValueTo(std::shared_ptr<FishEngine::BoxCollider> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Collider::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_center, target->m_center); // FishEngine::Vector3
		cloneUtility.Clone(this->m_size, target->m_size); // FishEngine::Vector3
	}


	// FishEngine::Cubemap
	void FishEngine::Cubemap::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Texture::Serialize(archive);
		archive << FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive << FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	void FishEngine::Cubemap::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Texture::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive >> FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}



	// FishEngine::Shader
	void FishEngine::Shader::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_uniforms", m_uniforms); // std::vector<UniformInfo>
		archive << FishEngine::make_nvp("m_cullface", m_cullface); // FishEngine::Cullface
		archive << FishEngine::make_nvp("m_ZWrite", m_ZWrite); // bool
		archive << FishEngine::make_nvp("m_blend", m_blend); // bool
		archive << FishEngine::make_nvp("m_deferred", m_deferred); // bool
		archive << FishEngine::make_nvp("m_blendFactorCount", m_blendFactorCount); // int
		archive << FishEngine::make_nvp("m_keywords", m_keywords); // ShaderKeywords
		//archive.EndClass();
	}

	void FishEngine::Shader::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_uniforms", m_uniforms); // std::vector<UniformInfo>
		archive >> FishEngine::make_nvp("m_cullface", m_cullface); // FishEngine::Cullface
		archive >> FishEngine::make_nvp("m_ZWrite", m_ZWrite); // bool
		archive >> FishEngine::make_nvp("m_blend", m_blend); // bool
		archive >> FishEngine::make_nvp("m_deferred", m_deferred); // bool
		archive >> FishEngine::make_nvp("m_blendFactorCount", m_blendFactorCount); // int
		archive >> FishEngine::make_nvp("m_keywords", m_keywords); // ShaderKeywords
		//archive.EndClass();
	}



	// FishEngine::Texture
	void FishEngine::Texture::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_height", m_height); // uint32_t
		archive << FishEngine::make_nvp("m_width", m_width); // uint32_t
		archive << FishEngine::make_nvp("m_anisoLevel", m_anisoLevel); // int
		archive << FishEngine::make_nvp("m_dimension", m_dimension); // FishEngine::TextureDimension
		archive << FishEngine::make_nvp("m_filterMode", m_filterMode); // FishEngine::FilterMode
		archive << FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::TextureWrapMode
		//archive.EndClass();
	}

	void FishEngine::Texture::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_height", m_height); // uint32_t
		archive >> FishEngine::make_nvp("m_width", m_width); // uint32_t
		archive >> FishEngine::make_nvp("m_anisoLevel", m_anisoLevel); // int
		archive >> FishEngine::make_nvp("m_dimension", m_dimension); // FishEngine::TextureDimension
		archive >> FishEngine::make_nvp("m_filterMode", m_filterMode); // FishEngine::FilterMode
		archive >> FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::TextureWrapMode
		//archive.EndClass();
	}



	// FishEngine::Rigidbody
	void FishEngine::Rigidbody::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_mass", m_mass); // float
		archive << FishEngine::make_nvp("m_drag", m_drag); // float
		archive << FishEngine::make_nvp("m_angularDrag", m_angularDrag); // float
		archive << FishEngine::make_nvp("m_useGravity", m_useGravity); // bool
		archive << FishEngine::make_nvp("m_isKinematic", m_isKinematic); // bool
		archive << FishEngine::make_nvp("m_velocity", m_velocity); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::Rigidbody::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_mass", m_mass); // float
		archive >> FishEngine::make_nvp("m_drag", m_drag); // float
		archive >> FishEngine::make_nvp("m_angularDrag", m_angularDrag); // float
		archive >> FishEngine::make_nvp("m_useGravity", m_useGravity); // bool
		archive >> FishEngine::make_nvp("m_isKinematic", m_isKinematic); // bool
		archive >> FishEngine::make_nvp("m_velocity", m_velocity); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Rigidbody::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Rigidbody>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Rigidbody::CopyValueTo(std::shared_ptr<FishEngine::Rigidbody> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_mass, target->m_mass); // float
		cloneUtility.Clone(this->m_drag, target->m_drag); // float
		cloneUtility.Clone(this->m_angularDrag, target->m_angularDrag); // float
		cloneUtility.Clone(this->m_useGravity, target->m_useGravity); // bool
		cloneUtility.Clone(this->m_isKinematic, target->m_isKinematic); // bool
		cloneUtility.Clone(this->m_velocity, target->m_velocity); // FishEngine::Vector3
	}


	// FishEngine::Component
	void FishEngine::Component::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_gameObject", m_gameObject); // std::weak_ptr<GameObject>
		//archive.EndClass();
	}

	void FishEngine::Component::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_gameObject", m_gameObject); // std::weak_ptr<GameObject>
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Component::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Component>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Component::CopyValueTo(std::shared_ptr<FishEngine::Component> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Object::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_gameObject, target->m_gameObject); // std::weak_ptr<GameObject>
	}


	// FishEngine::UniformInfo
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::UniformInfo const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("type", value.type); // GLenum
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("location", value.location); // GLuint
		archive << FishEngine::make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive << FishEngine::make_nvp("binded", value.binded); // bool
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::UniformInfo & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("type", value.type); // GLenum
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("location", value.location); // GLuint
		archive >> FishEngine::make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive >> FishEngine::make_nvp("binded", value.binded); // bool
		archive.EndClass();
		return archive;
	}

	// FishEngine::Behaviour
	void FishEngine::Behaviour::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		//archive.EndClass();
	}

	void FishEngine::Behaviour::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Behaviour::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Behaviour>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Behaviour::CopyValueTo(std::shared_ptr<FishEngine::Behaviour> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_enabled, target->m_enabled); // bool
	}


	// FishEngine::ShaderUniforms
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::ShaderUniforms const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive << FishEngine::make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive << FishEngine::make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive << FishEngine::make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive << FishEngine::make_nvp("floats", value.floats); // std::map<std::string, float>
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::ShaderUniforms & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive >> FishEngine::make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive >> FishEngine::make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive >> FishEngine::make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive >> FishEngine::make_nvp("floats", value.floats); // std::map<std::string, float>
		archive.EndClass();
		return archive;
	}

	// FishEngine::CapsuleCollider
	void FishEngine::CapsuleCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_direction", m_direction); // int
		archive << FishEngine::make_nvp("m_height", m_height); // float
		archive << FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	void FishEngine::CapsuleCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_direction", m_direction); // int
		archive >> FishEngine::make_nvp("m_height", m_height); // float
		archive >> FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::CapsuleCollider::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::CapsuleCollider>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::CapsuleCollider::CopyValueTo(std::shared_ptr<FishEngine::CapsuleCollider> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Collider::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_center, target->m_center); // FishEngine::Vector3
		cloneUtility.Clone(this->m_direction, target->m_direction); // int
		cloneUtility.Clone(this->m_height, target->m_height); // float
		cloneUtility.Clone(this->m_radius, target->m_radius); // float
	}


	// FishEngine::Mesh
	void FishEngine::Mesh::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_skinned", m_skinned); // bool
		archive << FishEngine::make_nvp("m_subMeshCount", m_subMeshCount); // int
		archive << FishEngine::make_nvp("m_vertices", m_vertices); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_normals", m_normals); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_uv", m_uv); // std::vector<Vector2>
		archive << FishEngine::make_nvp("m_tangents", m_tangents); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_triangles", m_triangles); // std::vector<uint32_t>
		archive << FishEngine::make_nvp("m_subMeshIndexOffset", m_subMeshIndexOffset); // std::vector<uint32_t>
		archive << FishEngine::make_nvp("m_bindposes", m_bindposes); // std::vector<Matrix4x4>
		archive << FishEngine::make_nvp("m_boneNames", m_boneNames); // std::vector<std::string>
		archive << FishEngine::make_nvp("m_isReadable", m_isReadable); // bool
		archive << FishEngine::make_nvp("m_uploaded", m_uploaded); // bool
		archive << FishEngine::make_nvp("m_vertexCount", m_vertexCount); // uint32_t
		archive << FishEngine::make_nvp("m_triangleCount", m_triangleCount); // uint32_t
		archive << FishEngine::make_nvp("m_bounds", m_bounds); // FishEngine::Bounds
		//archive.EndClass();
	}

	void FishEngine::Mesh::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_skinned", m_skinned); // bool
		archive >> FishEngine::make_nvp("m_subMeshCount", m_subMeshCount); // int
		archive >> FishEngine::make_nvp("m_vertices", m_vertices); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_normals", m_normals); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_uv", m_uv); // std::vector<Vector2>
		archive >> FishEngine::make_nvp("m_tangents", m_tangents); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_triangles", m_triangles); // std::vector<uint32_t>
		archive >> FishEngine::make_nvp("m_subMeshIndexOffset", m_subMeshIndexOffset); // std::vector<uint32_t>
		archive >> FishEngine::make_nvp("m_bindposes", m_bindposes); // std::vector<Matrix4x4>
		archive >> FishEngine::make_nvp("m_boneNames", m_boneNames); // std::vector<std::string>
		archive >> FishEngine::make_nvp("m_isReadable", m_isReadable); // bool
		archive >> FishEngine::make_nvp("m_uploaded", m_uploaded); // bool
		archive >> FishEngine::make_nvp("m_vertexCount", m_vertexCount); // uint32_t
		archive >> FishEngine::make_nvp("m_triangleCount", m_triangleCount); // uint32_t
		archive >> FishEngine::make_nvp("m_bounds", m_bounds); // FishEngine::Bounds
		//archive.EndClass();
	}



	// FishEngine::Renderer
	void FishEngine::Renderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive << FishEngine::make_nvp("m_materials", m_materials); // std::vector<MaterialPtr>
		archive << FishEngine::make_nvp("m_shadowCastingMode", m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive << FishEngine::make_nvp("m_receiveShadows", m_receiveShadows); // bool
		//archive.EndClass();
	}

	void FishEngine::Renderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive >> FishEngine::make_nvp("m_materials", m_materials); // std::vector<MaterialPtr>
		archive >> FishEngine::make_nvp("m_shadowCastingMode", m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive >> FishEngine::make_nvp("m_receiveShadows", m_receiveShadows); // bool
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Renderer::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		abort();
		return nullptr;
	}

	void FishEngine::Renderer::CopyValueTo(std::shared_ptr<FishEngine::Renderer> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Component::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_enabled, target->m_enabled); // bool
		cloneUtility.Clone(this->m_materials, target->m_materials); // std::vector<MaterialPtr>
		cloneUtility.Clone(this->m_shadowCastingMode, target->m_shadowCastingMode); // FishEngine::ShadowCastingMode
		cloneUtility.Clone(this->m_receiveShadows, target->m_receiveShadows); // bool
	}


	// FishEngine::Rect
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Rect const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("m_XMin", value.m_XMin); // float
		archive << FishEngine::make_nvp("m_YMin", value.m_YMin); // float
		archive << FishEngine::make_nvp("m_Width", value.m_Width); // float
		archive << FishEngine::make_nvp("m_Height", value.m_Height); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Rect & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("m_XMin", value.m_XMin); // float
		archive >> FishEngine::make_nvp("m_YMin", value.m_YMin); // float
		archive >> FishEngine::make_nvp("m_Width", value.m_Width); // float
		archive >> FishEngine::make_nvp("m_Height", value.m_Height); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::ShaderLabRangeProperty
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::ShaderLabRangeProperty const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("value", value.value); // float
		archive << FishEngine::make_nvp("minValue", value.minValue); // float
		archive << FishEngine::make_nvp("maxValue", value.maxValue); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::ShaderLabRangeProperty & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("value", value.value); // float
		archive >> FishEngine::make_nvp("minValue", value.minValue); // float
		archive >> FishEngine::make_nvp("maxValue", value.maxValue); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::MaterialProperty
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::MaterialProperty const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("type", value.type); // FishEngine::MaterialPropertyType
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::MaterialProperty & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("type", value.type); // FishEngine::MaterialPropertyType
		archive.EndClass();
		return archive;
	}

	// FishEngine::SkinnedMeshRenderer
	void FishEngine::SkinnedMeshRenderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Renderer::Serialize(archive);
		archive << FishEngine::make_nvp("m_sharedMesh", m_sharedMesh); // MeshPtr
		archive << FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive << FishEngine::make_nvp("m_rootBone", m_rootBone); // std::weak_ptr<Transform>
		archive << FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	void FishEngine::SkinnedMeshRenderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Renderer::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_sharedMesh", m_sharedMesh); // MeshPtr
		archive >> FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive >> FishEngine::make_nvp("m_rootBone", m_rootBone); // std::weak_ptr<Transform>
		archive >> FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::SkinnedMeshRenderer::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::SkinnedMeshRenderer>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::SkinnedMeshRenderer::CopyValueTo(std::shared_ptr<FishEngine::SkinnedMeshRenderer> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Renderer::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_sharedMesh, target->m_sharedMesh); // MeshPtr
		cloneUtility.Clone(this->m_avatar, target->m_avatar); // AvatarPtr
		cloneUtility.Clone(this->m_rootBone, target->m_rootBone); // std::weak_ptr<Transform>
		cloneUtility.Clone(this->m_bones, target->m_bones); // std::vector<std::weak_ptr<Transform> >
	}


	// FishEngine::SphereCollider
	void FishEngine::SphereCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	void FishEngine::SphereCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::SphereCollider::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::SphereCollider>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::SphereCollider::CopyValueTo(std::shared_ptr<FishEngine::SphereCollider> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Collider::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_center, target->m_center); // FishEngine::Vector3
		cloneUtility.Clone(this->m_radius, target->m_radius); // float
	}


	// FishEngine::BoneWeight
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::BoneWeight const & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::BoneWeight & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	// FishEngine::Bounds
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Bounds const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Bounds & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	// FishEngine::AnimationClip
	void FishEngine::AnimationClip::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Motion::Serialize(archive);
		archive << FishEngine::make_nvp("events", events); // std::vector<AnimationEvent>
		archive << FishEngine::make_nvp("frameRate", frameRate); // float
		archive << FishEngine::make_nvp("length", length); // float
		archive << FishEngine::make_nvp("wrapMode", wrapMode); // FishEngine::WrapMode
		//archive.EndClass();
	}

	void FishEngine::AnimationClip::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Motion::Deserialize(archive);
		archive >> FishEngine::make_nvp("events", events); // std::vector<AnimationEvent>
		archive >> FishEngine::make_nvp("frameRate", frameRate); // float
		archive >> FishEngine::make_nvp("length", length); // float
		archive >> FishEngine::make_nvp("wrapMode", wrapMode); // FishEngine::WrapMode
		//archive.EndClass();
	}



	// FishEngine::Color
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Color const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("r", value.r); // float
		archive << FishEngine::make_nvp("g", value.g); // float
		archive << FishEngine::make_nvp("b", value.b); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Color & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("r", value.r); // float
		archive >> FishEngine::make_nvp("g", value.g); // float
		archive >> FishEngine::make_nvp("b", value.b); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Light
	void FishEngine::Light::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_type", m_type); // FishEngine::LightType
		archive << FishEngine::make_nvp("m_range", m_range); // float
		archive << FishEngine::make_nvp("m_spotAngle", m_spotAngle); // float
		archive << FishEngine::make_nvp("m_color", m_color); // FishEngine::Color
		archive << FishEngine::make_nvp("m_intensity", m_intensity); // float
		archive << FishEngine::make_nvp("m_shadowBias", m_shadowBias); // float
		archive << FishEngine::make_nvp("m_shadowNormalBias", m_shadowNormalBias); // float
		archive << FishEngine::make_nvp("m_shadowNearPlane", m_shadowNearPlane); // float
		archive << FishEngine::make_nvp("m_shadowStrength", m_shadowStrength); // float
		//archive.EndClass();
	}

	void FishEngine::Light::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_type", m_type); // FishEngine::LightType
		archive >> FishEngine::make_nvp("m_range", m_range); // float
		archive >> FishEngine::make_nvp("m_spotAngle", m_spotAngle); // float
		archive >> FishEngine::make_nvp("m_color", m_color); // FishEngine::Color
		archive >> FishEngine::make_nvp("m_intensity", m_intensity); // float
		archive >> FishEngine::make_nvp("m_shadowBias", m_shadowBias); // float
		archive >> FishEngine::make_nvp("m_shadowNormalBias", m_shadowNormalBias); // float
		archive >> FishEngine::make_nvp("m_shadowNearPlane", m_shadowNearPlane); // float
		archive >> FishEngine::make_nvp("m_shadowStrength", m_shadowStrength); // float
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Light::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Light>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Light::CopyValueTo(std::shared_ptr<FishEngine::Light> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Behaviour::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_type, target->m_type); // FishEngine::LightType
		cloneUtility.Clone(this->m_range, target->m_range); // float
		cloneUtility.Clone(this->m_spotAngle, target->m_spotAngle); // float
		cloneUtility.Clone(this->m_color, target->m_color); // FishEngine::Color
		cloneUtility.Clone(this->m_intensity, target->m_intensity); // float
		cloneUtility.Clone(this->m_shadowBias, target->m_shadowBias); // float
		cloneUtility.Clone(this->m_shadowNormalBias, target->m_shadowNormalBias); // float
		cloneUtility.Clone(this->m_shadowNearPlane, target->m_shadowNearPlane); // float
		cloneUtility.Clone(this->m_shadowStrength, target->m_shadowStrength); // float
	}


	// FishEngine::AnimatorStateInfo
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimatorStateInfo const & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimatorStateInfo & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	// FishEngine::Avatar
	void FishEngine::Avatar::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_boneToIndex", m_boneToIndex); // std::map<std::string, int>
		archive << FishEngine::make_nvp("m_indexToBone", m_indexToBone); // std::map<int, std::string>
		archive << FishEngine::make_nvp("m_matrixPalette", m_matrixPalette); // std::vector<Matrix4x4>
		//archive.EndClass();
	}

	void FishEngine::Avatar::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_boneToIndex", m_boneToIndex); // std::map<std::string, int>
		archive >> FishEngine::make_nvp("m_indexToBone", m_indexToBone); // std::map<int, std::string>
		archive >> FishEngine::make_nvp("m_matrixPalette", m_matrixPalette); // std::vector<Matrix4x4>
		//archive.EndClass();
	}



	// FishEngine::Script
	void FishEngine::Script::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::Script::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Script::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Script>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Script::CopyValueTo(std::shared_ptr<FishEngine::Script> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Behaviour::CopyValueTo(target, cloneUtility);
	}


	// FishEngine::AnimationState
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimationState const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("blendMode", value.blendMode); // FishEngine::AnimationBlendMode
		archive << FishEngine::make_nvp("clip", value.clip); // std::shared_ptr<AnimationClip>
		archive << FishEngine::make_nvp("enabled", value.enabled); // bool
		archive << FishEngine::make_nvp("length", value.length); // float
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("normalizedSpeed", value.normalizedSpeed); // float
		archive << FishEngine::make_nvp("normalizedTime", value.normalizedTime); // float
		archive << FishEngine::make_nvp("speed", value.speed); // float
		archive << FishEngine::make_nvp("time", value.time); // float
		archive << FishEngine::make_nvp("weight", value.weight); // float
		archive << FishEngine::make_nvp("wrapMode", value.wrapMode); // FishEngine::WrapMode
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimationState & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("blendMode", value.blendMode); // FishEngine::AnimationBlendMode
		archive >> FishEngine::make_nvp("clip", value.clip); // std::shared_ptr<AnimationClip>
		archive >> FishEngine::make_nvp("enabled", value.enabled); // bool
		archive >> FishEngine::make_nvp("length", value.length); // float
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("normalizedSpeed", value.normalizedSpeed); // float
		archive >> FishEngine::make_nvp("normalizedTime", value.normalizedTime); // float
		archive >> FishEngine::make_nvp("speed", value.speed); // float
		archive >> FishEngine::make_nvp("time", value.time); // float
		archive >> FishEngine::make_nvp("weight", value.weight); // float
		archive >> FishEngine::make_nvp("wrapMode", value.wrapMode); // FishEngine::WrapMode
		archive.EndClass();
		return archive;
	}

	// FishEngine::Int4
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int4 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive << FishEngine::make_nvp("z", value.z); // int
		archive << FishEngine::make_nvp("w", value.w); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int4 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive >> FishEngine::make_nvp("z", value.z); // int
		archive >> FishEngine::make_nvp("w", value.w); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Frustum
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Frustum const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("fov", value.fov); // float
		archive << FishEngine::make_nvp("maxRange", value.maxRange); // float
		archive << FishEngine::make_nvp("minRange", value.minRange); // float
		archive << FishEngine::make_nvp("aspect", value.aspect); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Frustum & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("fov", value.fov); // float
		archive >> FishEngine::make_nvp("maxRange", value.maxRange); // float
		archive >> FishEngine::make_nvp("minRange", value.minRange); // float
		archive >> FishEngine::make_nvp("aspect", value.aspect); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Int3
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int3 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive << FishEngine::make_nvp("z", value.z); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int3 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive >> FishEngine::make_nvp("z", value.z); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Int2
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int2 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int2 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Prefab
	void FishEngine::Prefab::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_parentPrefab", m_parentPrefab); // PrefabPtr
		archive << FishEngine::make_nvp("m_rootGameObject", m_rootGameObject); // GameObjectPtr
		archive << FishEngine::make_nvp("m_isPrefabParent", m_isPrefabParent); // bool
		//archive.EndClass();
	}

	void FishEngine::Prefab::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_parentPrefab", m_parentPrefab); // PrefabPtr
		archive >> FishEngine::make_nvp("m_rootGameObject", m_rootGameObject); // GameObjectPtr
		archive >> FishEngine::make_nvp("m_isPrefabParent", m_isPrefabParent); // bool
		//archive.EndClass();
	}



	// FishEngine::Camera
	void FishEngine::Camera::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_fieldOfView", m_fieldOfView); // float
		archive << FishEngine::make_nvp("m_orthographicSize", m_orthographicSize); // float
		archive << FishEngine::make_nvp("m_aspect", m_aspect); // float
		archive << FishEngine::make_nvp("m_isAspectSet", m_isAspectSet); // bool
		archive << FishEngine::make_nvp("m_farClipPlane", m_farClipPlane); // float
		archive << FishEngine::make_nvp("m_nearClipPlane", m_nearClipPlane); // float
		archive << FishEngine::make_nvp("m_viewport", m_viewport); // FishEngine::Vector4
		archive << FishEngine::make_nvp("m_isDirty", m_isDirty); // bool
		archive << FishEngine::make_nvp("m_cameraType", m_cameraType); // FishEngine::CameraType
		archive << FishEngine::make_nvp("m_orthographic", m_orthographic); // bool
		//archive.EndClass();
	}

	void FishEngine::Camera::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_fieldOfView", m_fieldOfView); // float
		archive >> FishEngine::make_nvp("m_orthographicSize", m_orthographicSize); // float
		archive >> FishEngine::make_nvp("m_aspect", m_aspect); // float
		archive >> FishEngine::make_nvp("m_isAspectSet", m_isAspectSet); // bool
		archive >> FishEngine::make_nvp("m_farClipPlane", m_farClipPlane); // float
		archive >> FishEngine::make_nvp("m_nearClipPlane", m_nearClipPlane); // float
		archive >> FishEngine::make_nvp("m_viewport", m_viewport); // FishEngine::Vector4
		archive >> FishEngine::make_nvp("m_isDirty", m_isDirty); // bool
		archive >> FishEngine::make_nvp("m_cameraType", m_cameraType); // FishEngine::CameraType
		archive >> FishEngine::make_nvp("m_orthographic", m_orthographic); // bool
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Camera::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Camera>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Camera::CopyValueTo(std::shared_ptr<FishEngine::Camera> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Behaviour::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_fieldOfView, target->m_fieldOfView); // float
		cloneUtility.Clone(this->m_orthographicSize, target->m_orthographicSize); // float
		cloneUtility.Clone(this->m_aspect, target->m_aspect); // float
		cloneUtility.Clone(this->m_isAspectSet, target->m_isAspectSet); // bool
		cloneUtility.Clone(this->m_farClipPlane, target->m_farClipPlane); // float
		cloneUtility.Clone(this->m_nearClipPlane, target->m_nearClipPlane); // float
		cloneUtility.Clone(this->m_viewport, target->m_viewport); // FishEngine::Vector4
		cloneUtility.Clone(this->m_isDirty, target->m_isDirty); // bool
		cloneUtility.Clone(this->m_cameraType, target->m_cameraType); // FishEngine::CameraType
		cloneUtility.Clone(this->m_orthographic, target->m_orthographic); // bool
	}


	// FishEngine::Scene
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Scene const & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Scene & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	// FishEngine::MeshRenderer
	void FishEngine::MeshRenderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Renderer::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::MeshRenderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Renderer::Deserialize(archive);
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::MeshRenderer::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::MeshRenderer>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::MeshRenderer::CopyValueTo(std::shared_ptr<FishEngine::MeshRenderer> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Renderer::CopyValueTo(target, cloneUtility);
	}


	// FishEngine::Transform
	void FishEngine::Transform::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_localPosition", m_localPosition); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_localScale", m_localScale); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_localRotation", m_localRotation); // FishEngine::Quaternion
		archive << FishEngine::make_nvp("m_parent", m_parent); // std::weak_ptr<Transform>
		archive << FishEngine::make_nvp("m_children", m_children); // std::list<TransformPtr>
		//archive.EndClass();
	}

	void FishEngine::Transform::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_localPosition", m_localPosition); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_localScale", m_localScale); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_localRotation", m_localRotation); // FishEngine::Quaternion
		archive >> FishEngine::make_nvp("m_parent", m_parent); // std::weak_ptr<Transform>
		archive >> FishEngine::make_nvp("m_children", m_children); // std::list<TransformPtr>
		//archive.EndClass();
	}



	// FishEngine::Motion
	void FishEngine::Motion::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::Motion::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		//archive.EndClass();
	}



	// FishEngine::GameObject
	void FishEngine::GameObject::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_components", m_components); // std::list<ComponentPtr>
		archive << FishEngine::make_nvp("m_activeSelf", m_activeSelf); // bool
		archive << FishEngine::make_nvp("m_layer", m_layer); // int
		archive << FishEngine::make_nvp("m_tagIndex", m_tagIndex); // int
		archive << FishEngine::make_nvp("m_transform", m_transform); // TransformPtr
		//archive.EndClass();
	}

	void FishEngine::GameObject::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_components", m_components); // std::list<ComponentPtr>
		archive >> FishEngine::make_nvp("m_activeSelf", m_activeSelf); // bool
		archive >> FishEngine::make_nvp("m_layer", m_layer); // int
		archive >> FishEngine::make_nvp("m_tagIndex", m_tagIndex); // int
		archive >> FishEngine::make_nvp("m_transform", m_transform); // TransformPtr
		//archive.EndClass();
	}



	// FishEngine::AnimationEvent
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimationEvent const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("animationState", value.animationState); // FishEngine::AnimationState
		archive << FishEngine::make_nvp("animatorClipInfo", value.animatorClipInfo); // FishEngine::AnimatorClipInfo
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimationEvent & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("animationState", value.animationState); // FishEngine::AnimationState
		archive >> FishEngine::make_nvp("animatorClipInfo", value.animatorClipInfo); // FishEngine::AnimatorClipInfo
		archive.EndClass();
		return archive;
	}

	// FishEngine::Animation
	void FishEngine::Animation::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_isPlaying", m_isPlaying); // bool
		archive << FishEngine::make_nvp("m_playAutomatically", m_playAutomatically); // bool
		archive << FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::WrapMode
		//archive.EndClass();
	}

	void FishEngine::Animation::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_isPlaying", m_isPlaying); // bool
		archive >> FishEngine::make_nvp("m_playAutomatically", m_playAutomatically); // bool
		archive >> FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::WrapMode
		//archive.EndClass();
	}

	FishEngine::ComponentPtr FishEngine::Animation::Clone(FishEngine::CloneUtility & cloneUtility) const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Animation>();
		cloneUtility.m_clonedObject[this->GetInstanceID()] = ret;
		this->CopyValueTo(ret, cloneUtility);
		return ret;
	}

	void FishEngine::Animation::CopyValueTo(std::shared_ptr<FishEngine::Animation> target, FishEngine::CloneUtility & cloneUtility) const
	{
		FishEngine::Behaviour::CopyValueTo(target, cloneUtility);
		cloneUtility.Clone(this->m_isPlaying, target->m_isPlaying); // bool
		cloneUtility.Clone(this->m_playAutomatically, target->m_playAutomatically); // bool
		cloneUtility.Clone(this->m_wrapMode, target->m_wrapMode); // FishEngine::WrapMode
	}


} // namespace FishEngine
